<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binaural Therapy App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
            color: white;
            user-select: none;
            touch-action: manipulation;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: transform 0.3s;
            width: 90%;
            max-width: 400px;
        }
        #controls.hidden {
            transform: translateX(-50%) translateY(120%);
        }
        #playButton {
            position: relative;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
        }
        #playButton:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 25px rgba(0, 200, 255, 0.7);
        }
        .mode-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            text-align: left;
            margin: 5px 0;
        }
        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .mode-btn.active {
            background: linear-gradient(90deg, rgba(0, 150, 255, 0.3), rgba(100, 0, 255, 0.3));
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.3);
        }
        #statusBar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #4fc3f7, #7b1fa2);
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.5s;
            z-index: 3;
        }
        #timer {
            position: fixed;
            top: 10px;
            right: 15px;
            font-size: 14px;
            opacity: 0.7;
            z-index: 2;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 15px;
        }
        #ambienceMenu {
            position: fixed;
            bottom: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(10px);
            z-index: 2;
            display: none;
            flex-direction: column;
            gap: 8px;
            width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #ambienceMenu button {
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: left;
        }
        #ambienceMenu button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        #ambienceMenu button.active {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        #ambienceToggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            cursor: pointer;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s;
        }
        #ambienceToggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        #volumeControl {
            position: fixed;
            bottom: 80px;
            left: 20px;
            z-index: 2;
            width: 150px;
            opacity: 0.8;
        }
        #modeSelector {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 5px;
        }
        #modeSelector::-webkit-scrollbar {
            width: 5px;
        }
        #modeSelector::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        #modeSelector::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }
        .brainwave-info {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            max-width: 300px;
            text-align: center;
            z-index: 10;
            display: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .close-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        .info-icon {
            margin-left: 5px;
            cursor: help;
            font-size: 14px;
            opacity: 0.7;
        }
        .file-input-container {
            display: none;
            position: fixed;
            bottom: 180px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(10px);
            z-index: 2;
            flex-direction: column;
            gap: 8px;
            width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .file-input-container label {
            font-size: 12px;
            margin-bottom: 5px;
            display: block;
        }
        .file-input-container input[type="file"] {
            width: 100%;
            margin-bottom: 10px;
            font-size: 12px;
        }
        #startPrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .frequency-display {
            position: fixed;
            top: 10px;
            left: 15px;
            font-size: 14px;
            opacity: 0.7;
            z-index: 2;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 15px;
        }
    </style>
</head>
<body>
    <div id="startPrompt">
        <h2>Binaural Therapy App</h2>
        <p>Click anywhere to start audio</p>
    </div>

    <div id="statusBar"></div>
    <div id="timer"></div>
    <div class="frequency-display" id="frequencyDisplay">Left: 0Hz | Right: 0Hz</div>
    <div id="canvas"></div>
    
    <div id="controls" class="hidden">
        <div id="modeSelector">
            <button class="mode-btn" data-mode="gamma" data-freq="40">
                üöÄ Gamma (40Hz) - Peak Focus
                <span class="info-icon">‚ÑπÔ∏è</span>
            </button>
            <button class="mode-btn" data-mode="beta" data-freq="18">
                üí° Beta (18Hz) - Alert Concentration
                <span class="info-icon">‚ÑπÔ∏è</span>
            </button>
            <button class="mode-btn active" data-mode="alpha" data-freq="10">
                ‚òÅÔ∏è Alpha (10Hz) - Relaxed Awareness
                <span class="info-icon">‚ÑπÔ∏è</span>
            </button>
            <button class="mode-btn" data-mode="theta" data-freq="6">
                üåô Theta (6Hz) - Deep Meditation
                <span class="info-icon">‚ÑπÔ∏è</span>
            </button>
            <button class="mode-btn" data-mode="delta" data-freq="2">
                üí§ Delta (2Hz) - Deep Sleep
                <span class="info-icon">‚ÑπÔ∏è</span>
            </button>
        </div>
        <button id="playButton">‚ñ∂</button>
    </div>
    
    <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.5">
    
    <button id="ambienceToggle">üåø</button>
    <div id="ambienceMenu">
        <button data-sound="forest">üå≤ Forest</button>
        <button data-sound="ocean">üåä Ocean</button>
        <button data-sound="white">üåÄ White Noise</button>
        <button data-sound="off">‚ùå Turn Off</button>
    </div>

    <div class="brainwave-info" id="brainwaveInfo">
        <button class="close-info">√ó</button>
        <h3 id="infoTitle">Alpha Waves</h3>
        <p id="infoDescription">8-13Hz: Associated with relaxed awareness, meditation, and reduced anxiety.</p>
        <p><strong>Best for:</strong> Stress relief, light meditation, creativity</p>
    </div>

    <audio id="forestSound" preload="auto" loop></audio>
    <audio id="oceanSound" preload="auto" loop></audio>
    <audio id="whiteSound" preload="auto" loop></audio>

    <div id="fileInputContainer" class="file-input-container">
        <div>
            <label for="forestFile">Forest Sound:</label>
            <input type="file" id="forestFile" accept=".wav,.mp3,.ogg">
        </div>
        <div>
            <label for="oceanFile">Ocean Sound:</label>
            <input type="file" id="oceanFile" accept=".wav,.mp3,.ogg">
        </div>
        <div>
            <label for="whiteFile">White Noise:</label>
            <input type="file" id="whiteFile" accept=".wav,.mp3,.ogg">
        </div>
    </div>

    <script>
        // ===== BINAURAL AUDIO ENGINE =====
        class BinauralTherapy {
            constructor() {
                this.audioContext = null;
                this.currentMode = "alpha";
                this.binauralFrequency = 10; // The beat frequency difference between ears
                this.isPlaying = false;
                this.sessionStart = 0;
                this.currentAmbience = null;
                this.volume = 0.5;
                this.audioInitialized = false;
                this.fadeTime = 0.5;
                this.oscillators = { left: null, right: null };
                this.gainNodes = { left: null, right: null };
                this.carrierFrequency = 200; // Base frequency for both ears
                this.leftFrequency = 195; // Calculated left frequency
                this.rightFrequency = 205; // Calculated right frequency
                
                this.audioElements = {
                    forest: document.getElementById('forestSound'),
                    ocean: document.getElementById('oceanSound'),
                    white: document.getElementById('whiteSound')
                };
                
                this.initAudio = this.initAudio.bind(this);
            }
            
            async initAudio() {
                if (this.audioInitialized) return;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 44100
                    });
                    this.audioInitialized = true;
                    
                    document.getElementById('startPrompt').style.display = 'none';
                    
                    // Create audio nodes
                    this.merger = this.audioContext.createChannelMerger(2);
                    
                    // Master gain
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0;
                    
                    // Limiter to prevent clipping
                    this.limiter = this.audioContext.createDynamicsCompressor();
                    this.limiter.threshold.value = -1;
                    this.limiter.knee.value = 1;
                    this.limiter.ratio.value = 12;
                    this.limiter.attack.value = 0.003;
                    this.limiter.release.value = 0.025;
                    
                    // Connect audio graph
                    this.merger.connect(this.masterGain);
                    this.masterGain.connect(this.limiter);
                    this.limiter.connect(this.audioContext.destination);
                    
                    // Ambience system
                    this.ambienceGain = this.audioContext.createGain();
                    this.ambienceGain.gain.value = 0;
                    this.ambienceGain.connect(this.audioContext.destination);
                    
                    document.getElementById('controls').classList.remove('hidden');
                    
                    await this.loadDefaultLocalFiles();
                    
                } catch (error) {
                    console.error("Error initializing audio:", error);
                    alert("Error initializing audio. Please check console for details.");
                }
            }
            
            createOscillators() {
                if (!this.audioInitialized) return;
                
                this.stopOscillators();
                
                // Create pure sine wave oscillators
                this.oscillators.left = this.audioContext.createOscillator();
                this.oscillators.right = this.audioContext.createOscillator();
                
                // Create gain nodes for each oscillator
                this.gainNodes.left = this.audioContext.createGain();
                this.gainNodes.right = this.audioContext.createGain();
                
                // Configure oscillators as pure sine waves
                this.oscillators.left.type = 'sine';
                this.oscillators.right.type = 'sine';
                
                // Calculate frequencies for binaural beats
                this.leftFrequency = this.carrierFrequency - (this.binauralFrequency / 2);
                this.rightFrequency = this.carrierFrequency + (this.binauralFrequency / 2);
                
                // Set the frequencies
                this.oscillators.left.frequency.setValueAtTime(this.leftFrequency, this.audioContext.currentTime);
                this.oscillators.right.frequency.setValueAtTime(this.rightFrequency, this.audioContext.currentTime);
                
                // Set initial gain to 0 for smooth fade in
                this.gainNodes.left.gain.value = 0;
                this.gainNodes.right.gain.value = 0;
                
                // Connect left oscillator to left channel only
                this.oscillators.left.connect(this.gainNodes.left);
                this.gainNodes.left.connect(this.merger, 0, 0);
                
                // Connect right oscillator to right channel only
                this.oscillators.right.connect(this.gainNodes.right);
                this.gainNodes.right.connect(this.merger, 0, 1);
                
                // Start oscillators
                this.oscillators.left.start();
                this.oscillators.right.start();
                
                // Update frequency display
                this.updateFrequencyDisplay();
                
                console.log(`Binaural beat: Left=${this.leftFrequency.toFixed(1)}Hz, Right=${this.rightFrequency.toFixed(1)}Hz (${this.binauralFrequency}Hz beat)`);
            }
            
            updateFrequencyDisplay() {
                document.getElementById('frequencyDisplay').textContent = 
                    `Left: ${this.leftFrequency.toFixed(1)}Hz | Right: ${this.rightFrequency.toFixed(1)}Hz`;
            }
            
            stopOscillators() {
                const now = this.audioContext?.currentTime || 0;
                
                if (this.oscillators.left) {
                    this.gainNodes.left.gain.setValueAtTime(this.gainNodes.left.gain.value, now);
                    this.gainNodes.left.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    setTimeout(() => {
                        this.oscillators.left?.disconnect();
                        this.oscillators.left?.stop();
                        this.oscillators.left = null;
                    }, 100);
                }
                
                if (this.oscillators.right) {
                    this.gainNodes.right.gain.setValueAtTime(this.gainNodes.right.gain.value, now);
                    this.gainNodes.right.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    setTimeout(() => {
                        this.oscillators.right?.disconnect();
                        this.oscillators.right?.stop();
                        this.oscillators.right = null;
                    }, 100);
                }
            }
            
            async loadDefaultLocalFiles() {
                const soundFiles = [
                    { type: 'forest', file: 'forest.wav' },
                    { type: 'ocean', file: 'ocean.wav' },
                    { type: 'white', file: 'white.wav' }
                ];
                
                for (const {type, file} of soundFiles) {
                    try {
                        const response = await fetch(file);
                        if (response.ok) {
                            const blob = await response.blob();
                            const objectURL = URL.createObjectURL(blob);
                            this.audioElements[type].src = objectURL;
                        }
                    } catch (e) {
                        console.log(`Error loading ${file}:`, e);
                    }
                }
            }
            
            setMode(mode) {
                if (!this.audioInitialized) return;
                
                this.currentMode = mode;
                this.binauralFrequency = parseInt(document.querySelector(`.mode-btn[data-mode="${mode}"]`).dataset.freq);
                
                if (this.isPlaying) {
                    this.createOscillators();
                    // Fade in the new frequencies
                    const now = this.audioContext.currentTime;
                    this.gainNodes.left.gain.cancelScheduledValues(now);
                    this.gainNodes.right.gain.cancelScheduledValues(now);
                    this.gainNodes.left.gain.setValueAtTime(0, now);
                    this.gainNodes.right.gain.setValueAtTime(0, now);
                    this.gainNodes.left.gain.linearRampToValueAtTime(this.volume, now + this.fadeTime);
                    this.gainNodes.right.gain.linearRampToValueAtTime(this.volume, now + this.fadeTime);
                }
                this.updateStatusBar(this.isPlaying);
            }
            
            setAmbience(type) {
                if (!this.audioInitialized) return;
                
                const now = this.audioContext.currentTime;
                
                // Stop current ambience with fade out
                if (this.ambienceSource) {
                    this.ambienceGain.gain.cancelScheduledValues(now);
                    this.ambienceGain.gain.setTargetAtTime(0, now, 0.5);
                    setTimeout(() => {
                        if (this.ambienceSource) {
                            this.ambienceSource.disconnect();
                            this.ambienceSource = null;
                        }
                    }, 500);
                    this.audioElements[this.currentAmbience]?.pause();
                }
                
                // Start new ambience if selected (and not 'off')
                if (type && type !== 'off' && this.audioElements[type]) {
                    this.currentAmbience = type;
                    const element = this.audioElements[type];
                    
                    if (!element.src) {
                        console.log(`No sound file loaded for ${type}`);
                        return;
                    }
                    
                    element.loop = true;
                    
                    try {
                        // Create a media element source
                        this.ambienceSource = this.audioContext.createMediaElementSource(element);
                        this.ambienceSource.connect(this.ambienceGain);
                        
                        // Smooth fade in
                        this.ambienceGain.gain.cancelScheduledValues(now);
                        this.ambienceGain.gain.setValueAtTime(0, now);
                        this.ambienceGain.gain.setTargetAtTime(this.volume * 0.2, now, 1.5);
                        
                        // Play the audio element
                        const playPromise = element.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(error => {
                                console.error("Ambience playback failed:", error);
                            });
                        }
                    } catch (error) {
                        console.error("Error setting ambience:", error);
                    }
                } else {
                    this.currentAmbience = null;
                    if (type === 'off') {
                        document.getElementById('ambienceToggle').textContent = 'üåø';
                    }
                }
            }
            
            setVolume(volume) {
                if (!this.audioInitialized) return;
                
                this.volume = volume;
                const now = this.audioContext.currentTime;
                
                // Update binaural oscillators volume
                if (this.gainNodes.left && this.gainNodes.right) {
                    this.gainNodes.left.gain.cancelScheduledValues(now);
                    this.gainNodes.right.gain.cancelScheduledValues(now);
                    
                    if (this.isPlaying) {
                        this.gainNodes.left.gain.setTargetAtTime(volume, now, 0.1);
                        this.gainNodes.right.gain.setTargetAtTime(volume, now, 0.1);
                    } else {
                        this.gainNodes.left.gain.setValueAtTime(0, now);
                        this.gainNodes.right.gain.setValueAtTime(0, now);
                    }
                }
                
                // Update master gain for any other sounds
                this.masterGain.gain.cancelScheduledValues(now);
                
                if (this.isPlaying) {
                    this.masterGain.gain.setTargetAtTime(volume, now, 0.1);
                } else {
                    this.masterGain.gain.setValueAtTime(0, now);
                }
                
                // Update ambience volume
                if (this.currentAmbience && this.audioElements[this.currentAmbience]) {
                    this.audioElements[this.currentAmbience].volume = volume;
                    this.ambienceGain.gain.cancelScheduledValues(now);
                    this.ambienceGain.gain.setTargetAtTime(volume * 0.2, now, 0.1);
                }
            }
            
            async togglePlayback() {
                if (!this.audioInitialized) {
                    await this.initAudio();
                    return;
                }
                
                try {
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    const now = this.audioContext.currentTime;
                    
                    if (this.isPlaying) {
                        // Smooth fade out
                        if (this.gainNodes.left && this.gainNodes.right) {
                            this.gainNodes.left.gain.cancelScheduledValues(now);
                            this.gainNodes.right.gain.cancelScheduledValues(now);
                            this.gainNodes.left.gain.setTargetAtTime(0, now, this.fadeTime);
                            this.gainNodes.right.gain.setTargetAtTime(0, now, this.fadeTime);
                        }
                        
                        this.masterGain.gain.cancelScheduledValues(now);
                        this.masterGain.gain.setTargetAtTime(0, now, this.fadeTime);
                        
                        this.isPlaying = false;
                        this.updateTimer(false);
                    } else {
                        // Ensure we have oscillators created
                        if (!this.oscillators.left || !this.oscillators.right) {
                            this.createOscillators();
                        }
                        
                        // Smooth fade in
                        if (this.gainNodes.left && this.gainNodes.right) {
                            this.gainNodes.left.gain.cancelScheduledValues(now);
                            this.gainNodes.right.gain.cancelScheduledValues(now);
                            this.gainNodes.left.gain.setValueAtTime(0, now);
                            this.gainNodes.right.gain.setValueAtTime(0, now);
                            this.gainNodes.left.gain.linearRampToValueAtTime(this.volume, now + this.fadeTime);
                            this.gainNodes.right.gain.linearRampToValueAtTime(this.volume, now + this.fadeTime);
                        }
                        
                        this.masterGain.gain.cancelScheduledValues(now);
                        this.masterGain.gain.setValueAtTime(0, now);
                        this.masterGain.gain.setTargetAtTime(this.volume, now, this.fadeTime);
                        
                        this.isPlaying = true;
                        this.sessionStart = this.sessionStart || this.audioContext.currentTime;
                        this.updateTimer(true);
                    }
                    
                    return this.isPlaying;
                } catch (e) {
                    console.warn("Playback error:", e);
                    return false;
                }
            }
            
            updateTimer(running) {
                const timerEl = document.getElementById('timer');
                if (!running) {
                    timerEl.textContent = '';
                    return;
                }
                
                const update = () => {
                    if (!this.isPlaying) return;
                    
                    const seconds = Math.floor(this.audioContext.currentTime - this.sessionStart);
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    timerEl.textContent = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
                    
                    requestAnimationFrame(update);
                };
                
                update();
            }
            
            updateStatusBar(active) {
                const statusBar = document.getElementById('statusBar');
                if (active) {
                    const scale = 0.8 + 0.2 * Math.sin(this.audioContext.currentTime * (this.binauralFrequency / 2));
                    
                    let gradient;
                    switch(this.currentMode) {
                        case 'gamma':
                            gradient = 'linear-gradient(90deg, #ff00ff, #00ffff)';
                            break;
                        case 'beta':
                            gradient = 'linear-gradient(90deg, #00ff00, #ffff00)';
                            break;
                        case 'alpha':
                            gradient = 'linear-gradient(90deg, #4fc3f7, #7b1fa2)';
                            break;
                        case 'theta':
                            gradient = 'linear-gradient(90deg, #7b1fa2, #e91e63)';
                            break;
                        case 'delta':
                            gradient = 'linear-gradient(90deg, #3a1c71, #d76d77)';
                            break;
                        default:
                            gradient = 'linear-gradient(90deg, #4fc3f7, #7b1fa2)';
                    }
                    
                    statusBar.style.transform = `scaleX(${scale})`;
                    statusBar.style.background = gradient;
                    requestAnimationFrame(() => this.updateStatusBar(true));
                } else {
                    statusBar.style.transform = 'scaleX(0)';
                }
            }
        }

        // ===== PARTICLE VISUALIZER =====
        class ParticleVisualizer {
            constructor(container) {
                this.container = container;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 50;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.container.appendChild(this.renderer.domElement);
                
                this.breathPhase = 0;
                this.breathSpeed = 0.01;
                this.currentMode = 'alpha';
                this.intensity = 0;
                
                this.orbParticles = this.createOrbParticles(5000);
                this.galaxyParticles = this.createGalaxyParticles(10000);
                
                this.scene.add(this.orbParticles);
                this.scene.add(this.galaxyParticles);
                
                this.ambientLight = new THREE.AmbientLight(0x222244);
                this.scene.add(this.ambientLight);
                
                this.renderer.setAnimationLoop(() => this.animate());
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            createOrbParticles(count) {
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    const radius = 5 * Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    colors[i * 3] = 0.3 + Math.random() * 0.7;
                    colors[i * 3 + 1] = 0.2 + Math.random() * 0.5;
                    colors[i * 3 + 2] = 0.7 + Math.random() * 0.3;
                    
                    sizes[i] = 0.1 + Math.random() * 0.3;
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const particleSystem = new THREE.Points(particles, material);
                particleSystem.userData = {
                    originalPositions: positions.slice(),
                    originalColors: colors.slice()
                };
                
                return particleSystem;
            }
            
            createGalaxyParticles(count) {
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    const radius = 10 + Math.random() * 80;
                    const angle = Math.random() * Math.PI * 2;
                    const spiral = Math.random() * Math.PI * 4;
                    
                    positions[i * 3] = radius * Math.cos(angle + spiral) * (0.8 + Math.random() * 0.4);
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
                    positions[i * 3 + 2] = radius * Math.sin(angle + spiral) * (0.8 + Math.random() * 0.4);
                    
                    colors[i * 3] = 0.5 + Math.random() * 0.5;
                    colors[i * 3 + 1] = 0.3 + Math.random() * 0.7;
                    colors[i * 3 + 2] = 0.5 + Math.random() * 0.5;
                    
                    sizes[i] = 0.05 + Math.random() * 0.2;
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const particleSystem = new THREE.Points(particles, material);
                particleSystem.userData = {
                    originalColors: colors.slice()
                };
                
                return particleSystem;
            }
            
            setMode(mode) {
                this.currentMode = mode;
                this.updateColors();
                
                switch(mode) {
                    case 'gamma': this.breathSpeed = 0.03; break;
                    case 'beta': this.breathSpeed = 0.02; break;
                    case 'alpha': this.breathSpeed = 0.015; break;
                    case 'theta': this.breathSpeed = 0.01; break;
                    case 'delta': this.breathSpeed = 0.005; break;
                    default: this.breathSpeed = 0.01;
                }
            }
            
            updateColors() {
                const orbColors = this.orbParticles.geometry.attributes.color.array;
                const galaxyColors = this.galaxyParticles.geometry.attributes.color.array;
                const origOrbColors = this.orbParticles.userData.originalColors;
                const origGalaxyColors = this.galaxyParticles.userData.originalColors;
                
                let colorShiftR = 0, colorShiftG = 0, colorShiftB = 0;
                
                switch(this.currentMode) {
                    case 'gamma':
                        colorShiftR = 0.8; colorShiftG = 0.2; colorShiftB = 0.8;
                        break;
                    case 'beta':
                        colorShiftR = 0.2; colorShiftG = 0.8; colorShiftB = 0.2;
                        break;
                    case 'alpha':
                        colorShiftR = 0.3; colorShiftG = 0.5; colorShiftB = 0.8;
                        break;
                    case 'theta':
                        colorShiftR = 0.7; colorShiftG = 0.3; colorShiftB = 0.7;
                        break;
                    case 'delta':
                        colorShiftR = 0.4; colorShiftG = 0.1; colorShiftB = 0.5;
                        break;
                }
                
                for (let i = 0; i < orbColors.length; i += 3) {
                    orbColors[i] = origOrbColors[i] * (1 - colorShiftR) + colorShiftR;
                    orbColors[i + 1] = origOrbColors[i + 1] * (1 - colorShiftG) + colorShiftG;
                    orbColors[i + 2] = origOrbColors[i + 2] * (1 - colorShiftB) + colorShiftB;
                }
                
                for (let i = 0; i < galaxyColors.length; i += 3) {
                    galaxyColors[i] = origGalaxyColors[i] * (1 - colorShiftR) + colorShiftR;
                    galaxyColors[i + 1] = origGalaxyColors[i + 1] * (1 - colorShiftG) + colorShiftG;
                    galaxyColors[i + 2] = origGalaxyColors[i + 2] * (1 - colorShiftB) + colorShiftB;
                }
                
                this.orbParticles.geometry.attributes.color.needsUpdate = true;
                this.galaxyParticles.geometry.attributes.color.needsUpdate = true;
                
                let lightColor;
                switch(this.currentMode) {
                    case 'gamma': lightColor = new THREE.Color(0x330066); break;
                    case 'beta': lightColor = new THREE.Color(0x003300); break;
                    case 'alpha': lightColor = new THREE.Color(0x000044); break;
                    case 'theta': lightColor = new THREE.Color(0x220022); break;
                    case 'delta': lightColor = new THREE.Color(0x110011); break;
                    default: lightColor = new THREE.Color(0x000044);
                }
                this.ambientLight.color.copy(lightColor);
            }
            
            animate() {
                this.breathPhase += this.breathSpeed;
                const breathScale = 1 + (0.3 + this.intensity * 0.2) * Math.sin(this.breathPhase);
                
                const positions = this.orbParticles.geometry.attributes.position.array;
                const originalPositions = this.orbParticles.userData.originalPositions;
                
                for (let i = 0; i < positions.length; i++) {
                    positions[i] = originalPositions[i] * breathScale;
                }
                this.orbParticles.geometry.attributes.position.needsUpdate = true;
                
                const opacity = 0.6 + (0.3 + this.intensity * 0.1) * Math.sin(this.breathPhase * 2);
                this.orbParticles.material.opacity = opacity;
                this.galaxyParticles.material.opacity = opacity * 0.9;
                this.orbParticles.material.needsUpdate = true;
                this.galaxyParticles.material.needsUpdate = true;
                
                this.galaxyParticles.rotation.y += 0.0005 + (this.intensity * 0.0003);
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Brainwave information data
        const brainwaveInfo = {
            gamma: {
                title: "Gamma Waves (30-100Hz)",
                description: "Associated with peak concentration, high-level cognition, and problem-solving.",
                benefits: "Enhances cognitive processing, memory recall, and sensory perception."
            },
            beta: {
                title: "Beta Waves (13-30Hz)",
                description: "Present during normal waking consciousness and active thinking.",
                benefits: "Improves focus, alertness, and analytical thinking."
            },
            alpha: {
                title: "Alpha Waves (8-13Hz)",
                description: "Occur during relaxed states, light meditation, and daydreaming.",
                benefits: "Reduces stress, enhances creativity, and promotes relaxation."
            },
            theta: {
                title: "Theta Waves (4-8Hz)",
                description: "Present during deep meditation, REM sleep, and creative inspiration.",
                benefits: "Deep meditation, enhanced intuition, and emotional healing."
            },
            delta: {
                title: "Delta Waves (0.5-4Hz)",
                description: "The slowest brainwaves, occurring in deep, dreamless sleep.",
                benefits: "Promotes deep sleep, healing, and immune system functioning."
            }
        };

        // ===== MAIN APP =====
        document.addEventListener('DOMContentLoaded', async () => {
            const container = document.getElementById('canvas');
            const playButton = document.getElementById('playButton');
            const ambienceToggle = document.getElementById('ambienceToggle');
            const ambienceMenu = document.getElementById('ambienceMenu');
            const controls = document.getElementById('controls');
            const volumeControl = document.getElementById('volumeControl');
            const brainwaveInfoEl = document.getElementById('brainwaveInfo');
            const infoTitle = document.getElementById('infoTitle');
            const infoDescription = document.getElementById('infoDescription');
            const fileInputContainer = document.getElementById('fileInputContainer');
            const forestFileInput = document.getElementById('forestFile');
            const oceanFileInput = document.getElementById('oceanFile');
            const whiteFileInput = document.getElementById('whiteFile');
            
            // Initialize systems
            const visualizer = new ParticleVisualizer(container);
            const audioTherapy = new BinauralTherapy();
            
            // Set initial volume
            volumeControl.addEventListener('input', () => {
                audioTherapy.setVolume(volumeControl.value);
            });
            
            // Play/pause button
            playButton.addEventListener('click', async () => {
                const isPlaying = await audioTherapy.togglePlayback();
                playButton.textContent = isPlaying ? '‚ùö‚ùö' : '‚ñ∂';
                
                if (isPlaying) {
                    audioTherapy.updateStatusBar(true);
                }
            });
            
            // Mode selection
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const mode = btn.dataset.mode;
                    audioTherapy.setMode(mode);
                    visualizer.setMode(mode);
                    
                    if ('vibrate' in navigator) {
                        navigator.vibrate(10);
                    }
                });
            });
            
            // Info icons
            document.querySelectorAll('.info-icon').forEach(icon => {
                icon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const mode = icon.parentElement.dataset.mode;
                    infoTitle.textContent = brainwaveInfo[mode].title;
                    infoDescription.textContent = brainwaveInfo[mode].description + " " + brainwaveInfo[mode].benefits;
                    brainwaveInfoEl.style.display = 'block';
                });
            });
            
            // Close info panel
            document.querySelector('.close-info').addEventListener('click', () => {
                brainwaveInfoEl.style.display = 'none';
            });
            
            // Ambience menu toggle
            ambienceToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                ambienceMenu.style.display = ambienceMenu.style.display === 'flex' ? 'none' : 'flex';
                fileInputContainer.style.display = 'none';
            });
            
            // File input toggle
            ambienceToggle.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                fileInputContainer.style.display = fileInputContainer.style.display === 'flex' ? 'none' : 'flex';
                ambienceMenu.style.display = 'none';
            });
            
            // File input handlers
            forestFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    audioTherapy.audioElements.forest.src = url;
                }
            });
            
            oceanFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    audioTherapy.audioElements.ocean.src = url;
                }
            });
            
            whiteFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    audioTherapy.audioElements.white.src = url;
                }
            });
            
            // Ambience selection
            ambienceMenu.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    ambienceMenu.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    
                    if (btn.dataset.sound !== 'off') {
                        btn.classList.add('active');
                    }
                    
                    const soundType = btn.dataset.sound;
                    audioTherapy.setAmbience(soundType);
                    
                    if (soundType !== 'off') {
                        ambienceToggle.textContent = 
                            soundType === 'forest' ? 'üå≤' :
                            soundType === 'ocean' ? 'üåä' : 'üåÄ';
                    }
                    
                    ambienceMenu.style.display = 'none';
                });
            });
            
            // Initialize audio on first click
            document.body.addEventListener('click', () => {
                audioTherapy.initAudio();
            }, { once: true });
            
            // Hide controls after inactivity
            let hideTimeout;
            const resetHideTimeout = () => {
                clearTimeout(hideTimeout);
                controls.classList.remove('hidden');
                hideTimeout = setTimeout(() => {
                    controls.classList.add('hidden');
                }, 3000);
            };
            
            document.addEventListener('mousemove', resetHideTimeout);
            document.addEventListener('touchmove', resetHideTimeout);
            resetHideTimeout();
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    playButton.click();
                } else if (e.code === 'KeyM') {
                    const modes = ['gamma', 'beta', 'alpha', 'theta', 'delta'];
                    const currentIndex = modes.indexOf(audioTherapy.currentMode);
                    const nextIndex = (currentIndex + 1) % modes.length;
                    document.querySelector(`.mode-btn[data-mode="${modes[nextIndex]}"]`).click();
                } else if (e.code === 'KeyA') {
                    ambienceToggle.click();
                } else if (e.code === 'KeyV') {
                    volumeControl.focus();
                } else if (e.code === 'Escape') {
                    brainwaveInfoEl.style.display = 'none';
                }
            });
        });
    </script>
</body>
</html>
